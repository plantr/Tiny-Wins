---
phase: 01-test-infrastructure-setup
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/test-utils.tsx
  - app/(tabs)/settings.test.tsx
autonomous: true

must_haves:
  truths:
    - "A test file importing render from lib/test-utils.tsx can render a component inside all 4 context providers without manual provider wrapping"
    - "The custom render wrapper re-exports all RNTL utilities so tests only need one import source"
    - "AsyncStorage operations in tests read/write correctly through the mocked module and are isolated between test cases"
    - "A smoke test renders a real app component (Settings screen), interacts with it (toggle theme), and asserts observable behavior change"
    - "Running `npx jest` executes both the smoke test and exits cleanly with passing results and coverage summary"
  artifacts:
    - path: "lib/test-utils.tsx"
      provides: "Custom render wrapper with QueryClientProvider, ThemeProvider, PremiumProvider, IdentityProvider, HabitsProvider and re-exported RNTL utilities"
      min_lines: 30
      exports: ["render"]
    - path: "app/(tabs)/settings.test.tsx"
      provides: "Smoke test proving infrastructure works end-to-end with real component rendering and user interaction"
      min_lines: 30
      contains: "describe"
  key_links:
    - from: "lib/test-utils.tsx"
      to: "lib/theme-context.tsx"
      via: "ThemeProvider import and wrapping"
      pattern: "ThemeProvider"
    - from: "lib/test-utils.tsx"
      to: "lib/habits-context.tsx"
      via: "HabitsProvider import and wrapping"
      pattern: "HabitsProvider"
    - from: "lib/test-utils.tsx"
      to: "lib/identity-context.tsx"
      via: "IdentityProvider import and wrapping"
      pattern: "IdentityProvider"
    - from: "lib/test-utils.tsx"
      to: "lib/premium-context.tsx"
      via: "PremiumProvider import and wrapping"
      pattern: "PremiumProvider"
    - from: "app/(tabs)/settings.test.tsx"
      to: "lib/test-utils.tsx"
      via: "import render, screen, waitFor"
      pattern: "from.*lib/test-utils"
    - from: "app/(tabs)/settings.test.tsx"
      to: "app/(tabs)/settings.tsx"
      via: "imports and renders SettingsScreen"
      pattern: "import.*settings"
---

<objective>
Create the custom render wrapper with all 4 context providers and a smoke test that renders a real app component, interacts with it, and asserts observable behavior.

Purpose: Prove the full test infrastructure works end-to-end -- from custom render wrapping through context providers to AsyncStorage-backed state. The smoke test validates that all the mocks from Plan 01 work together correctly and that downstream phases can test real components.

Output: lib/test-utils.tsx (custom render wrapper) and app/(tabs)/settings.test.tsx (smoke test proving everything works).
</objective>

<execution_context>
@/Users/robert.plant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robert.plant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-test-infrastructure-setup/01-RESEARCH.md
@.planning/phases/01-test-infrastructure-setup/01-01-SUMMARY.md
@app/_layout.tsx
@lib/theme-context.tsx
@lib/habits-context.tsx
@lib/identity-context.tsx
@lib/premium-context.tsx
@lib/query-client.ts
@app/(tabs)/settings.tsx
@constants/colors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create custom render wrapper with all context providers</name>
  <files>lib/test-utils.tsx</files>
  <action>
Create `lib/test-utils.tsx` following the RNTL custom render pattern. This file must:

1. **Create a fresh QueryClient per render** to prevent query cache pollution between tests:
   ```tsx
   import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

   function createTestQueryClient() {
     return new QueryClient({
       defaultOptions: {
         queries: { retry: false },
         mutations: { retry: false },
       },
     });
   }
   ```

2. **Wrap all 4 context providers in the same nesting order as app/_layout.tsx**:
   - QueryClientProvider (outermost)
   - ThemeProvider
   - PremiumProvider
   - IdentityProvider
   - HabitsProvider (innermost)

   Note: GestureHandlerRootView and KeyboardProvider are NOT included -- they are native wrappers already mocked in jest.setup.js and would add unnecessary complexity.

3. **Create the AllProviders wrapper component**:
   ```tsx
   function AllProviders({ children }: { children: React.ReactNode }) {
     const queryClient = createTestQueryClient();
     return (
       <QueryClientProvider client={queryClient}>
         <ThemeProvider>
           <PremiumProvider>
             <IdentityProvider>
               <HabitsProvider>
                 {children}
               </HabitsProvider>
             </IdentityProvider>
           </PremiumProvider>
         </ThemeProvider>
       </QueryClientProvider>
     );
   }
   ```

4. **Create customRender that passes AllProviders as wrapper**:
   ```tsx
   function customRender(
     ui: React.ReactElement,
     options?: Omit<RenderOptions, 'wrapper'>
   ) {
     return render(ui, { wrapper: AllProviders, ...options });
   }
   ```

5. **Re-export everything from @testing-library/react-native** for single-import convenience:
   ```tsx
   export * from '@testing-library/react-native';
   export { customRender as render };
   ```

   This means tests import `{ render, screen, waitFor, fireEvent }` from `@/lib/test-utils` instead of mixing imports from RNTL and a separate utils file.

IMPORTANT: ThemeProvider has `if (!loaded) return null` which means it blocks rendering until AsyncStorage resolves. The AsyncStorage mock from jest.setup.js resolves synchronously, but the Provider's useEffect runs asynchronously. Tests MUST use `waitFor` to wait for providers to hydrate. Document this in a comment at the top of the file.
  </action>
  <verify>
The file should:
- Import from all 4 context files and @tanstack/react-query
- Export `render` (custom), plus re-export `screen`, `waitFor`, `fireEvent`, etc. from RNTL
- TypeScript compilation should not error: `npx tsc --noEmit lib/test-utils.tsx` (or let Jest transpile it)
  </verify>
  <done>lib/test-utils.tsx exists with AllProviders wrapper in correct nesting order, customRender function, and re-exports from RNTL. Tests can import everything from one source.</done>
</task>

<task type="auto">
  <name>Task 2: Create smoke test with Settings screen rendering and theme toggle interaction</name>
  <files>app/(tabs)/settings.test.tsx</files>
  <action>
Create `app/(tabs)/settings.test.tsx` as the smoke test proving the full infrastructure works. This test file targets the Settings screen because:
- It consumes all 3 non-trivial contexts (useTheme, usePremium, useHabits)
- It has testable text content ("settings" title, "Light"/"Dark" buttons, "Version 1.0.0")
- It has an interactive element (theme toggle pills) that exercises state changes through ThemeProvider + AsyncStorage
- It does NOT use routing for its core rendering (no router.push in the main render path)

The smoke test file should contain:

**Test 1: Renders Settings screen with all providers** (proves TINF-03 + mocks work)
```tsx
import { render, screen, waitFor } from '@/lib/test-utils';
import AsyncStorage from '@react-native-async-storage/async-storage';
import SettingsScreen from './settings';

describe('Settings Screen (Smoke Test)', () => {
  it('renders the settings screen with all context providers', async () => {
    render(<SettingsScreen />);

    // Wait for ThemeProvider to load from AsyncStorage
    await waitFor(() => {
      expect(screen.getByText('settings')).toBeOnTheScreen();
    });

    // Verify key sections render
    expect(screen.getByText('General')).toBeOnTheScreen();
    expect(screen.getByText('Version')).toBeOnTheScreen();
    expect(screen.getByText('1.0.0')).toBeOnTheScreen();
  });
```

**Test 2: Theme toggle interaction** (proves render + interaction + state change works end-to-end)
```tsx
  it('shows theme mode indicator matching current theme', async () => {
    render(<SettingsScreen />);

    await waitFor(() => {
      expect(screen.getByText('settings')).toBeOnTheScreen();
    });

    // Default theme is dark -- check the mode indicator text
    expect(screen.getByText('Dark mode active')).toBeOnTheScreen();
  });
```

**Test 3: AsyncStorage isolation** (proves TINF-04 -- tests don't bleed)
```tsx
  it('starts with clean AsyncStorage state each test', async () => {
    // This test runs after the previous ones -- if afterEach cleanup works,
    // AsyncStorage should be empty
    const allKeys = await AsyncStorage.getAllKeys();
    expect(allKeys).toHaveLength(0);

    // Pre-seed specific values and verify they read back
    await AsyncStorage.setItem('test_key', 'test_value');
    const value = await AsyncStorage.getItem('test_key');
    expect(value).toBe('test_value');
  });
});
```

The smoke test uses `@/lib/test-utils` (path alias) for imports. If the path alias does not resolve in Jest, use a relative path `../../lib/test-utils` instead. The jest-expo preset should resolve tsconfig paths, but verify.

If the tsconfig path alias `@/*` does not work in Jest, add `moduleNameMapper` to jest.config.js:
```js
moduleNameMapper: {
  '^@/(.*)$': '<rootDir>/$1',
  '^@shared/(.*)$': '<rootDir>/shared/$1',
}
```
  </action>
  <verify>
Run `npx jest` and verify:
1. All 3 smoke tests pass (green output)
2. No warnings about missing mocks or unhandled promises
3. Coverage summary prints showing files from app/ and lib/
4. Exit code is 0
5. Run `npx jest --verbose` to see individual test names passing

If any test fails, debug by:
- Check if ThemeProvider's AsyncStorage loading is causing timeout (increase waitFor timeout)
- Check if any unmocked native module is throwing (add mock to jest.setup.js)
- Check if path alias @/ is not resolving (add moduleNameMapper)
  </verify>
  <done>app/(tabs)/settings.test.tsx has 3 passing tests: component renders with all providers, theme mode indicator shows correctly, and AsyncStorage is isolated between tests. `npx jest` passes with exit code 0 and coverage summary.</done>
</task>

</tasks>

<verification>
1. `npx jest` finds and runs all tests in settings.test.tsx
2. All 3 tests pass (render, theme mode, AsyncStorage isolation)
3. Coverage report generates (terminal shows file-level percentages)
4. No console warnings about unmocked modules
5. Exit code is 0
6. `npx jest --coverage` generates HTML report in coverage/ directory
7. coverage/ directory is gitignored
</verification>

<success_criteria>
- Custom render wrapper wraps components in all 4 context providers matching app nesting order
- Tests import render, screen, waitFor from a single source (lib/test-utils)
- Smoke test renders a real app component (SettingsScreen) and asserts visible content
- Smoke test interacts with the rendered component (verifies theme state)
- AsyncStorage isolation test proves cleanup works between tests
- `npx jest` passes all tests and prints coverage
</success_criteria>

<output>
After completion, create `.planning/phases/01-test-infrastructure-setup/01-02-SUMMARY.md`
</output>
