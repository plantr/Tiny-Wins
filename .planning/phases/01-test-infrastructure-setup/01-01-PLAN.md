---
phase: 01-test-infrastructure-setup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - jest.config.js
  - jest.setup.js
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "Running `npx jest` exits cleanly (no config errors, no unresolved module errors)"
    - "AsyncStorage mock is available and isolated between tests (clear in afterEach)"
    - "All native modules used by the app have working mocks (no undefined/import errors)"
    - "Coverage reporting generates a summary to terminal"
  artifacts:
    - path: "jest.config.js"
      provides: "Jest configuration with jest-expo preset, coverage settings, transformIgnorePatterns"
      contains: "preset.*jest-expo"
    - path: "jest.setup.js"
      provides: "Global mocks for AsyncStorage, Reanimated, Gesture Handler, Keyboard Controller, Haptics, Router, LinearGradient, SafeAreaContext, vector icons, and other native modules"
      contains: "async-storage-mock"
    - path: "package.json"
      provides: "test, test:watch, test:coverage, test:ci scripts"
      contains: "jest"
    - path: ".gitignore"
      provides: "coverage/ directory excluded from git"
      contains: "coverage"
  key_links:
    - from: "jest.config.js"
      to: "jest.setup.js"
      via: "setupFilesAfterEnv"
      pattern: "setupFilesAfterEnv.*jest\\.setup"
    - from: "jest.config.js"
      to: "jest-expo"
      via: "preset field"
      pattern: "preset.*jest-expo"
---

<objective>
Install Jest 30 + React Native Testing Library and configure the test runner with all native module mocks needed by this codebase.

Purpose: Establish the test execution foundation so that `npx jest` runs without errors and all native modules used throughout the app are properly mocked. This is the prerequisite for any test file to function.

Output: Working jest.config.js, jest.setup.js with comprehensive native module mocks, test scripts in package.json, and coverage/ in .gitignore.
</objective>

<execution_context>
@/Users/robert.plant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robert.plant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-test-infrastructure-setup/01-RESEARCH.md
@app/_layout.tsx
@package.json
@babel.config.js
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install test dependencies and add npm scripts</name>
  <files>package.json</files>
  <action>
Install test dependencies using the Expo-recommended approach:

```bash
npx expo install jest-expo jest @types/jest --dev
npm install --save-dev @testing-library/react-native
```

Note: Do NOT install @testing-library/jest-native -- it is deprecated and RNTL 12.4+ includes built-in matchers automatically.

Add the following scripts to package.json:
- "test": "jest"
- "test:watch": "jest --watch"
- "test:coverage": "jest --coverage"
- "test:ci": "jest --ci --coverage --maxWorkers=2"

Also add "coverage" to .gitignore so generated coverage reports are not committed.
  </action>
  <verify>
Run `npm test -- --version` or `npx jest --version` to confirm Jest is installed and runnable. Verify @testing-library/react-native is in devDependencies. Verify @testing-library/jest-native is NOT installed.
  </verify>
  <done>jest-expo, jest, @types/jest, and @testing-library/react-native are in devDependencies. Four test scripts exist in package.json. coverage/ is in .gitignore.</done>
</task>

<task type="auto">
  <name>Task 2: Create Jest configuration and comprehensive native module mocks</name>
  <files>jest.config.js, jest.setup.js</files>
  <action>
Create jest.config.js at project root with:
- `preset: 'jest-expo'`
- `setupFilesAfterEnv: ['<rootDir>/jest.setup.js']` (NOT setupFiles -- native mocks need the Jest environment)
- `transformIgnorePatterns` covering: react-native, @react-native, expo, @expo, @expo-google-fonts, react-navigation, @react-navigation, @unimodules, native-base, react-native-svg, react-native-reanimated, react-native-gesture-handler, react-native-keyboard-controller, react-native-safe-area-context, react-native-screens, react-native-worklets
- `collectCoverageFrom` targeting: app/**/*.{ts,tsx}, components/**/*.{ts,tsx}, lib/**/*.{ts,tsx} -- excluding *.d.ts, node_modules, .expo, coverage, server, shared
- `coverageThreshold` at 0% for ALL metrics initially (branches, functions, lines, statements). The threshold will be raised once there are enough tests to meet it. Set to 0 now so the infrastructure works without blocking on empty coverage. A comment should note: "Raise to 70% by Phase 4 per TINF-06 requirement."
- `coverageReporters: ['text', 'lcov', 'html']`
- `testMatch: ['**/*.test.{ts,tsx}', '**/*.spec.{ts,tsx}']` to support co-located test files per TINF-05

Create jest.setup.js at project root with these mocks (order matters):

1. **AsyncStorage mock** (first -- contexts depend on it):
   ```js
   jest.mock('@react-native-async-storage/async-storage', () =>
     require('@react-native-async-storage/async-storage/jest/async-storage-mock')
   );
   ```

2. **Gesture Handler mock**:
   ```js
   import 'react-native-gesture-handler/jestSetup';
   ```

3. **Reanimated mock**:
   ```js
   require('react-native-reanimated').setUpTests();
   ```

4. **Keyboard Controller mock**:
   ```js
   jest.mock('react-native-keyboard-controller', () =>
     require('react-native-keyboard-controller/jest')
   );
   ```

5. **Expo Haptics mock** (used in almost every screen):
   ```js
   jest.mock('expo-haptics', () => ({
     impactAsync: jest.fn(() => Promise.resolve()),
     notificationAsync: jest.fn(() => Promise.resolve()),
     selectionAsync: jest.fn(() => Promise.resolve()),
     ImpactFeedbackStyle: { Light: 'light', Medium: 'medium', Heavy: 'heavy' },
     NotificationFeedbackType: { Success: 'success', Warning: 'warning', Error: 'error' },
   }));
   ```

6. **Expo Router mock** (used in every screen for navigation):
   ```js
   jest.mock('expo-router', () => ({
     router: { push: jest.fn(), replace: jest.fn(), back: jest.fn(), canGoBack: jest.fn(() => false) },
     useRouter: jest.fn(() => ({ push: jest.fn(), replace: jest.fn(), back: jest.fn(), canGoBack: jest.fn(() => false) })),
     useLocalSearchParams: jest.fn(() => ({})),
     Stack: ({ children }) => children || null,
     Tabs: ({ children }) => children || null,
     Link: ({ children }) => children || null,
   }));
   ```

7. **Expo Linear Gradient mock** (used in nearly every screen):
   ```js
   jest.mock('expo-linear-gradient', () => ({
     LinearGradient: ({ children, ...props }) => {
       const { View } = require('react-native');
       return <View {...props}>{children}</View>;
     },
   }));
   ```

8. **React Native Safe Area Context mock**:
   ```js
   jest.mock('react-native-safe-area-context', () => {
     const insets = { top: 0, right: 0, bottom: 0, left: 0 };
     return {
       SafeAreaProvider: ({ children }) => children,
       SafeAreaView: ({ children }) => children,
       useSafeAreaInsets: jest.fn(() => insets),
     };
   });
   ```

9. **Expo Vector Icons mock** (Ionicons, Feather used across screens):
   ```js
   jest.mock('@expo/vector-icons', () => {
     const { Text } = require('react-native');
     const MockIcon = ({ name, ...props }) => <Text {...props}>{name}</Text>;
     return { Ionicons: MockIcon, Feather: MockIcon, MaterialIcons: MockIcon };
   });
   ```

10. **Expo Splash Screen mock**:
    ```js
    jest.mock('expo-splash-screen', () => ({
      preventAutoHideAsync: jest.fn(() => Promise.resolve()),
      hideAsync: jest.fn(() => Promise.resolve()),
    }));
    ```

11. **Expo Status Bar mock**:
    ```js
    jest.mock('expo-status-bar', () => ({
      StatusBar: () => null,
    }));
    ```

12. **Expo Image Picker mock** (used in Today tab):
    ```js
    jest.mock('expo-image-picker', () => ({
      launchImageLibraryAsync: jest.fn(() => Promise.resolve({ canceled: true, assets: [] })),
      MediaTypeOptions: { Images: 'Images' },
      requestMediaLibraryPermissionsAsync: jest.fn(() => Promise.resolve({ status: 'granted' })),
    }));
    ```

13. **Expo File System mock** (used in settings):
    ```js
    jest.mock('expo-file-system', () => ({
      documentDirectory: '/mock/documents/',
      writeAsStringAsync: jest.fn(() => Promise.resolve()),
      EncodingType: { UTF8: 'utf8' },
    }));
    ```

14. **Expo Sharing mock** (used in settings):
    ```js
    jest.mock('expo-sharing', () => ({
      isAvailableAsync: jest.fn(() => Promise.resolve(true)),
      shareAsync: jest.fn(() => Promise.resolve()),
    }));
    ```

15. **Expo Blur mock** (used in tab layout):
    ```js
    jest.mock('expo-blur', () => ({
      BlurView: ({ children }) => children || null,
    }));
    ```

16. **Expo Glass Effect mock** (used in tab layout):
    ```js
    jest.mock('expo-glass-effect', () => ({
      isLiquidGlassAvailable: jest.fn(() => false),
    }));
    ```

17. **Expo Font mock**:
    ```js
    jest.mock('expo-font', () => ({
      useFonts: jest.fn(() => [true]),
      loadAsync: jest.fn(() => Promise.resolve()),
    }));
    ```

18. **Expo Image mock** (used for optimized images):
    ```js
    jest.mock('expo-image', () => ({
      Image: ({ ...props }) => {
        const { View } = require('react-native');
        return <View {...props} />;
      },
    }));
    ```

19. **AsyncStorage afterEach cleanup** (critical for test isolation per TINF-04):
    ```js
    afterEach(async () => {
      const AsyncStorage = require('@react-native-async-storage/async-storage').default;
      await AsyncStorage.clear();
    });
    ```

Note: Use JSX in jest.setup.js. The file extension is .js but jest-expo preset handles JSX transpilation. If JSX causes issues, rename to jest.setup.tsx or use React.createElement calls instead.

IMPORTANT: The coverage threshold starts at 0% (not 70%) because a single smoke test cannot meet 70% across a full codebase. The TINF-06 requirement will be met incrementally -- the threshold will be raised to 70% by Phase 4 when sufficient test coverage exists. This is the approach recommended in the research (Pitfall 4).
  </action>
  <verify>
Create a minimal placeholder test file (e.g., `lib/sanity.test.ts`) with a single test:
```ts
describe('Jest setup', () => {
  it('runs a test', () => {
    expect(1 + 1).toBe(2);
  });
});
```
Run `npx jest` and verify:
1. It finds and runs the test
2. No mock/import errors in console output
3. Coverage summary prints to terminal
4. Exit code is 0

Delete the placeholder test file after verification.
  </verify>
  <done>jest.config.js exists with jest-expo preset, coverage config, and co-located test pattern. jest.setup.js exists with mocks for all 16+ native modules used by the app. Running `npx jest` with a simple test file exits cleanly with coverage summary.</done>
</task>

</tasks>

<verification>
1. `npx jest --version` outputs Jest 30.x
2. `npx jest` with a minimal test exits cleanly (exit code 0)
3. Coverage summary appears in terminal output
4. No "Cannot find module" or "SyntaxError: Unexpected token" errors
5. package.json has test, test:watch, test:coverage, test:ci scripts
6. .gitignore contains coverage entry
</verification>

<success_criteria>
- Jest 30 + jest-expo preset installed and configured
- All native modules used by the app have mocks in jest.setup.js
- AsyncStorage mock clears after each test
- Coverage reporting works (terminal + HTML)
- A simple test file runs and passes via `npx jest`
</success_criteria>

<output>
After completion, create `.planning/phases/01-test-infrastructure-setup/01-01-SUMMARY.md`
</output>
