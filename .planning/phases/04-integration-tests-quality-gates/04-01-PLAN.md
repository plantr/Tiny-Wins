---
phase: 04-integration-tests-quality-gates
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/habits-context.test.tsx
  - lib/__tests__/habit-completion-workflow.test.tsx
autonomous: true

must_haves:
  truths:
    - "HabitsProvider CRUD cycle works: addHabit creates, updateHabit modifies, removeHabit deletes"
    - "All CRUD operations persist to AsyncStorage and survive simulated app restart"
    - "HabitsProvider hydrates habits, logs, and reviews from pre-seeded AsyncStorage on mount"
    - "completeHabit creates a log entry and increments streak, both persisted"
    - "uncompleteHabit removes today's log and decrements streak, both persisted"
    - "Tapping HabitGridCard check triggers completion callback and EvidenceModal becomes visible"
    - "Submitting evidence through EvidenceModal calls completeHabit and log persists to AsyncStorage"
  artifacts:
    - path: "lib/habits-context.test.tsx"
      provides: "HabitsProvider integration test suite"
    - path: "lib/__tests__/habit-completion-workflow.test.tsx"
      provides: "Multi-component habit completion workflow integration test"
  key_links:
    - from: "lib/habits-context.test.tsx"
      to: "lib/habits-context.tsx"
      via: "useHabits hook through test helper component"
      pattern: "useHabits\\(\\)"
    - from: "lib/habits-context.test.tsx"
      to: "AsyncStorage"
      via: "getItem/setItem assertions for persistence verification"
      pattern: "AsyncStorage\\.(getItem|setItem)"
    - from: "lib/__tests__/habit-completion-workflow.test.tsx"
      to: "components/habits/HabitGridCard.tsx"
      via: "renders HabitGridCard and triggers onComplete"
      pattern: "HabitGridCard"
    - from: "lib/__tests__/habit-completion-workflow.test.tsx"
      to: "components/modals/EvidenceModal.tsx"
      via: "verifies EvidenceModal renders after completion"
      pattern: "EvidenceModal"
    - from: "lib/__tests__/habit-completion-workflow.test.tsx"
      to: "lib/habits-context.tsx"
      via: "completeHabit called via EvidenceModal onSubmit, persistence verified"
      pattern: "completeHabit"
---

<objective>
Test HabitsProvider CRUD operations with AsyncStorage persistence using TDD, plus a multi-component workflow integration test for the habit completion flow.

Purpose: HabitsProvider is the most complex provider (344 lines, 3 storage keys, 11 public methods). Testing its CRUD cycle with persistence verification ensures the core data layer is reliable (success criterion 1). The multi-component workflow test exercises the full completion chain: HabitGridCard -> EvidenceModal -> completeHabit -> log persists (success criterion 3).

Output: lib/habits-context.test.tsx with provider integration tests, and lib/__tests__/habit-completion-workflow.test.tsx with the multi-component UI workflow test.
</objective>

<execution_context>
@/Users/robert.plant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robert.plant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/habits-context.tsx
@lib/test-utils.tsx
@jest.config.js
@components/habits/HabitGridCard.tsx
@components/modals/EvidenceModal.tsx
@app/(tabs)/index.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HabitsProvider CRUD and persistence integration tests</name>
  <files>lib/habits-context.test.tsx</files>
  <action>
Create lib/habits-context.test.tsx with a TestHabitsHook helper component that exposes useHabits() values via testID'd Text elements and Pressable buttons for triggering actions.

**Helper component pattern:**
```tsx
function TestHabitsHook({ onReady }: { onReady?: (ctx: ReturnType<typeof useHabits>) => void }) {
  const ctx = useHabits();
  // Expose values via testID Text elements
  // Expose actions via Pressable buttons with testIDs
}
```

Expose via testIDs:
- `loaded` (isLoaded), `habit-count` (habits.length), `log-count` (logs.length), `review-count` (reviews.length)
- For first habit: `habit-0-title`, `habit-0-streak`, `habit-0-current`, `habit-0-bestStreak`
- Action buttons: `add-habit`, `update-habit`, `remove-habit`, `complete-habit`, `uncomplete-habit`, `log-missed`, `increment-habit`, `add-review`

Use `render()` from `@/lib/test-utils` (wraps in all providers including HabitsProvider).

**Test cases (RED-GREEN for each group):**

1. **Hydration tests:**
   - Starts with empty habits when no storage data
   - Hydrates habits from pre-seeded AsyncStorage (pre-seed with `AsyncStorage.setItem('tinywins_habits', JSON.stringify([testHabit]))`)
   - Hydrates logs from pre-seeded AsyncStorage
   - Hydrates reviews from pre-seeded AsyncStorage
   - Handles corrupted storage data gracefully (pre-seed with invalid JSON)

2. **CRUD tests:**
   - addHabit: adds habit with generated id, zeroed current/streak/weekData, persists to AsyncStorage
   - updateHabit: modifies title, persists updated habit to AsyncStorage
   - removeHabit: removes habit by id, persists updated list to AsyncStorage

3. **Completion flow tests:**
   - completeHabit: sets current to goal, increments streak, creates "done" log, persists both habits and logs
   - uncompleteHabit: resets current to 0, decrements streak (min 0), removes today's done log, persists both
   - logMissed: resets streak to 0, creates "missed" log, persists both
   - incrementHabit: increments current by 1, updates weekData for current day

4. **App restart simulation:**
   - Add habit -> unmount -> remount -> habit still present (verify full persistence cycle)

**Important patterns:**
- `beforeEach(async () => { await AsyncStorage.clear(); })` to isolate tests
- Always `await waitFor(() => expect(screen.getByTestId('loaded')).toHaveTextContent('true'))` before assertions
- Use fake timers (`jest.useFakeTimers({ now: new Date('2026-02-16T12:00:00Z') })`) for deterministic date/time in log entries
- Verify persistence with dual assertions: check rendered testID AND `AsyncStorage.getItem()` value
- Use `act()` wrapper if needed for state updates triggered by button presses

**Test data factory:**
```typescript
const makeTestHabit = (overrides = {}) => ({
  id: 'test-habit-1',
  title: 'Morning Run',
  icon: 'fitness',
  iconColor: '#4ADE80',
  gradientColors: ['#4ADE80', '#22C55E'] as const,
  goal: 1,
  unit: 'times',
  frequency: 'Daily',
  current: 0,
  streak: 0,
  bestStreak: 0,
  weekData: [0, 0, 0, 0, 0, 0, 0],
  createdAt: Date.now(),
  ...overrides,
});
```

Target: ~15-20 test cases covering all CRUD operations and persistence verification.
  </action>
  <verify>
Run `npx jest lib/habits-context.test.tsx --verbose` and confirm all tests pass.
Run `npx jest lib/habits-context.test.tsx --coverage` and confirm habits-context.tsx coverage is above 80% for statements, branches, functions, and lines.
  </verify>
  <done>
HabitsProvider test file exists with passing tests that verify: (1) hydration from AsyncStorage, (2) all CRUD operations with persistence, (3) completion/uncomplete/missed flows with streak and log management, (4) app restart simulation showing data survives unmount/remount. Coverage of habits-context.tsx exceeds 80%.
  </done>
</task>

<task type="auto">
  <name>Task 2: Multi-component habit completion workflow integration test</name>
  <files>lib/__tests__/habit-completion-workflow.test.tsx</files>
  <action>
Create lib/__tests__/habit-completion-workflow.test.tsx that tests the full multi-component habit completion flow end-to-end: HabitGridCard -> EvidenceModal -> completeHabit -> persistence.

**Architecture:** The app's index.tsx orchestrates this flow: HabitGridCard's `onComplete` callback opens EvidenceModal, and EvidenceModal's `onSubmit` calls `completeHabit()`. This test recreates that orchestration in a minimal test wrapper.

**Test wrapper component pattern:**
```tsx
function HabitCompletionWorkflow() {
  const { habits, completeHabit, uncompleteHabit, logs, addHabit } = useHabits();
  const [evidenceModal, setEvidenceModal] = useState<{ visible: boolean; habitId: string; habitTitle: string }>({
    visible: false, habitId: '', habitTitle: '',
  });

  const handleComplete = (habitId: string) => {
    const habit = habits.find(h => h.id === habitId);
    if (habit) setEvidenceModal({ visible: true, habitId, habitTitle: habit.title });
  };

  const handleSubmitEvidence = (note: string, imageUri?: string) => {
    completeHabit(evidenceModal.habitId, note || undefined, undefined, imageUri);
    setEvidenceModal({ visible: false, habitId: '', habitTitle: '' });
  };

  const handleSkip = () => {
    completeHabit(evidenceModal.habitId);
    setEvidenceModal({ visible: false, habitId: '', habitTitle: '' });
  };

  const handleCloseEvidence = () => {
    setEvidenceModal({ visible: false, habitId: '', habitTitle: '' });
  };

  // Render: add-habit button, HabitGridCard for each habit, EvidenceModal, testID'd status displays
  return (
    <View>
      <Text testID="habit-count">{habits.length}</Text>
      <Text testID="log-count">{logs.length}</Text>
      <Text testID="evidence-visible">{evidenceModal.visible.toString()}</Text>
      <Pressable testID="seed-habit" onPress={() => addHabit({
        title: 'Morning Run', icon: 'fitness', iconColor: '#4ADE80',
        gradientColors: ['#4ADE80', '#22C55E'], goal: 1, unit: 'times', frequency: 'Daily',
      })} />
      {habits.map((habit, idx) => (
        <HabitGridCard
          key={habit.id}
          habit={habit}
          index={idx}
          isCompleted={habit.current >= habit.goal}
          onComplete={handleComplete}
          onUncomplete={uncompleteHabit}
        />
      ))}
      <EvidenceModal
        visible={evidenceModal.visible}
        habitTitle={evidenceModal.habitTitle}
        onSubmit={handleSubmitEvidence}
        onSkip={handleSkip}
        onClose={handleCloseEvidence}
      />
    </View>
  );
}
```

Use `render()` from `@/lib/test-utils` (wraps in all providers).

**Test cases (~5-7 tests):**

1. **HabitGridCard check opens EvidenceModal:**
   - Seed a habit via `seed-habit` button, wait for it to render
   - Find HabitGridCard's check button (the Pressable with the checkmark/ellipse icon) and press it
   - Verify `evidence-visible` shows 'true' (EvidenceModal is now visible)
   - Verify EvidenceModal shows the habit title text ("Morning Run")

2. **Submit evidence completes habit and persists log:**
   - Seed habit, press check to open EvidenceModal
   - Type a note in the TextInput (placeholder "What did you do?")
   - Press "save evidence" button
   - Verify EvidenceModal closes (`evidence-visible` = 'false')
   - Verify `log-count` increments to '1'
   - Verify AsyncStorage contains the log with evidenceNote matching typed note

3. **Skip evidence still completes habit:**
   - Seed habit, press check to open EvidenceModal
   - Press "skip" button
   - Verify EvidenceModal closes
   - Verify habit streak increments (check the streak display on HabitGridCard or via testID)
   - Verify log persists to AsyncStorage with status "done" and no evidenceNote

4. **Close evidence does NOT complete habit:**
   - Seed habit, press check to open EvidenceModal
   - Press the close (X) button on EvidenceModal
   - Verify EvidenceModal closes
   - Verify `log-count` is still '0' (no completion happened)

5. **Full end-to-end: complete -> streak increments -> log persists:**
   - Seed habit, verify initial streak is 0
   - Press check -> EvidenceModal appears -> submit evidence with note "Ran 5km"
   - Verify streak display shows 1 (or habit-0-streak if using testIDs from HabitGridCard)
   - Verify AsyncStorage `tinywins_logs` contains log entry with habitId, status "done", evidenceNote "Ran 5km"
   - Verify AsyncStorage `tinywins_habits` shows updated streak and current values

**Important patterns:**
- `beforeEach(async () => { await AsyncStorage.clear(); })` to isolate tests
- Wait for providers to load before interacting: `await waitFor(() => expect(screen.getByTestId('habit-count')).toBeTruthy())`
- Use `fireEvent.press()` for button presses and `fireEvent.changeText()` for TextInput
- Use fake timers for deterministic timestamps in log entries
- The EvidenceModal uses React Native `Modal` component -- RNTL renders Modal children when `visible={true}`, so standard queries work
- HabitGridCard uses Reanimated -- the jest mock from Phase 1 setup handles this
  </action>
  <verify>
Run `npx jest lib/__tests__/habit-completion-workflow.test.tsx --verbose` and confirm all tests pass.
Verify that the test exercises the full chain: HabitGridCard press -> EvidenceModal visible -> submit/skip -> completeHabit called -> AsyncStorage updated.
  </verify>
  <done>
Multi-component workflow test file exists with passing tests that verify: (1) HabitGridCard check button opens EvidenceModal, (2) submitting evidence calls completeHabit and persists log with note, (3) skipping evidence still completes and persists, (4) closing modal does NOT complete, (5) full end-to-end chain with streak increment and AsyncStorage persistence verified. This satisfies phase success criterion 3: "complete habit -> streak increments -> evidence modal appears -> log persists."
  </done>
</task>

</tasks>

<verification>
1. `npx jest lib/habits-context.test.tsx --verbose` -- all tests pass
2. `npx jest lib/habits-context.test.tsx --coverage` -- habits-context.tsx coverage above 80% for all 4 metrics
3. `npx jest lib/__tests__/habit-completion-workflow.test.tsx --verbose` -- all workflow tests pass
4. `npx jest --testPathPattern="habits-context|habit-completion"` -- no regressions in existing test suite
</verification>

<success_criteria>
- lib/habits-context.test.tsx exists with 15+ passing test cases
- HabitsProvider CRUD cycle (create, read, update, delete) verified with AsyncStorage persistence
- Completion/uncomplete/missed flows verified with streak and log assertions
- Hydration from pre-seeded AsyncStorage verified
- App restart simulation passes (data survives unmount/remount)
- habits-context.tsx coverage exceeds 80% for all 4 metrics
- lib/__tests__/habit-completion-workflow.test.tsx exists with passing tests exercising HabitGridCard -> EvidenceModal -> completeHabit -> persistence (satisfies success criterion 3)
</success_criteria>

<output>
After completion, create `.planning/phases/04-integration-tests-quality-gates/04-01-SUMMARY.md`
</output>
