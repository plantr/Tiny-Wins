---
phase: 04-integration-tests-quality-gates
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/theme-context.test.tsx
  - lib/identity-context.test.tsx
  - lib/premium-context.test.tsx
autonomous: true

must_haves:
  truths:
    - "ThemeProvider dark/light mode switching persists across simulated app restart"
    - "ThemeProvider weekStartDay preference persists across simulated app restart"
    - "IdentityProvider selected areas and identity statement persist to AsyncStorage"
    - "PremiumProvider canCreateHabit returns false when count reaches 10 (free tier limit)"
    - "PremiumProvider isFeatureLocked returns false for premium users"
  artifacts:
    - path: "lib/theme-context.test.tsx"
      provides: "ThemeProvider integration tests with persistence"
    - path: "lib/identity-context.test.tsx"
      provides: "IdentityProvider integration tests with persistence"
    - path: "lib/premium-context.test.tsx"
      provides: "PremiumProvider feature gating tests"
  key_links:
    - from: "lib/theme-context.test.tsx"
      to: "lib/theme-context.tsx"
      via: "useTheme hook through test helper component"
      pattern: "useTheme\\(\\)"
    - from: "lib/theme-context.test.tsx"
      to: "AsyncStorage"
      via: "persistence verification for theme mode and week start day"
      pattern: "AsyncStorage\\.getItem\\('app_theme_mode'\\)"
    - from: "lib/identity-context.test.tsx"
      to: "lib/identity-context.tsx"
      via: "useIdentity hook through test helper component"
      pattern: "useIdentity\\(\\)"
    - from: "lib/premium-context.test.tsx"
      to: "lib/premium-context.tsx"
      via: "usePremium hook through test helper component"
      pattern: "usePremium\\(\\)"
---

<objective>
Test ThemeProvider, IdentityProvider, and PremiumProvider with persistence and feature gating.

Purpose: These three providers are simpler than HabitsProvider but each has distinct testing concerns: ThemeProvider needs app-restart simulation (success criterion 2), IdentityProvider needs compound state persistence, PremiumProvider needs exact limit testing (success criterion 4). Batching them in one plan keeps context budget efficient.

Output: Three co-located test files covering persistence, hydration, and feature gating for all three providers.
</objective>

<execution_context>
@/Users/robert.plant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robert.plant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/theme-context.tsx
@lib/identity-context.tsx
@lib/premium-context.tsx
@lib/test-utils.tsx
@jest.config.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ThemeProvider and IdentityProvider integration tests</name>
  <files>lib/theme-context.test.tsx, lib/identity-context.test.tsx</files>
  <action>
**ThemeProvider tests (lib/theme-context.test.tsx):**

Create a TestThemeHook helper component exposing useTheme() values:
- testIDs: `mode` (mode), `isDark` (isDark.toString()), `week-start` (weekStartDay)
- Action buttons: `toggle-theme`, `set-light`, `set-dark`, `set-week-start-sunday`, `set-week-start-friday`

Use `render()` from `@/lib/test-utils` (wraps in all providers).

Test cases (~8-10 tests):

1. **Defaults:**
   - Starts with dark mode as default
   - Starts with Monday as default weekStartDay

2. **Theme switching + persistence:**
   - toggleTheme switches dark to light, persists 'light' to AsyncStorage key 'app_theme_mode'
   - setTheme('light') switches to light, persists to AsyncStorage
   - toggleTheme twice returns to dark, persists 'dark'

3. **App restart simulation (critical -- success criterion 2):**
   - Set theme to light -> unmount -> remount fresh -> verify mode is still 'light'
   - Set weekStartDay to Sunday -> unmount -> remount fresh -> verify weekStartDay is still 'Sunday'

4. **Hydration edge cases:**
   - Invalid storage value (e.g., 'blue') is ignored, defaults to dark
   - Valid weekStartDay from storage is hydrated correctly

**Important patterns:**
- `beforeEach(async () => { await AsyncStorage.clear(); })`
- Wait for ThemeProvider to load (ThemeProvider renders null until loaded, so wait for content to appear)
- For restart: use `const { unmount } = render(<TestThemeHook />)`, then `unmount()`, then `render(<TestThemeHook />)` again
- Verify persistence: check both rendered text AND AsyncStorage.getItem()

---

**IdentityProvider tests (lib/identity-context.test.tsx):**

Create a TestIdentityHook helper component exposing useIdentity() values:
- testIDs: `loaded` (isLoaded), `area-count` (selectedAreaIds.length), `statement` (identityStatement), `selected-areas` (JSON.stringify(selectedAreaIds))
- Action buttons: `set-areas` (calls setSelectedAreaIds with ['athlete', 'reader'])), `set-statement` (calls setIdentityStatement with 'I am a healthy person')

Use `render()` from `@/lib/test-utils`.

Test cases (~6-8 tests):

1. **Defaults:**
   - Starts with empty selectedAreaIds
   - Starts with empty identityStatement

2. **State updates + persistence:**
   - setSelectedAreaIds persists to AsyncStorage key 'tinywins_identity' as JSON with selectedAreaIds field
   - setIdentityStatement persists to AsyncStorage with identityStatement field
   - Both fields persist together (compound state)

3. **Hydration:**
   - Pre-seed AsyncStorage with selectedAreaIds and identityStatement, verify hydrated on mount
   - getSelectedAreas returns matching IdentityArea objects for selected IDs

4. **Edge cases:**
   - Corrupted storage data is handled gracefully (empty state, no crash)

**Important patterns:**
- IdentityProvider uses compound persistence (single key, JSON with both fields)
- Storage key: 'tinywins_identity'
- Verify stored JSON shape: `{ selectedAreaIds: string[], identityStatement: string }`
  </action>
  <verify>
Run `npx jest lib/theme-context.test.tsx lib/identity-context.test.tsx --verbose` and confirm all tests pass.
Run `npx jest lib/theme-context.test.tsx lib/identity-context.test.tsx --coverage` and confirm theme-context.tsx and identity-context.tsx both exceed 80% coverage.
  </verify>
  <done>
ThemeProvider test file verifies: dark/light mode switching persists across app restart, weekStartDay persists, invalid storage is handled. IdentityProvider test file verifies: selected areas and statement persist, compound state is correct, hydration works. Both provider files exceed 80% coverage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PremiumProvider feature gating tests</name>
  <files>lib/premium-context.test.tsx</files>
  <action>
**PremiumProvider tests (lib/premium-context.test.tsx):**

Create a TestPremiumHook helper component exposing usePremium() values:
- testIDs: `isPremium` (isPremium.toString()), `freeHabitLimit` (freeHabitLimit), `showPaywall` (showPaywall.toString()), `paywallTrigger` (paywallTrigger)
- Dynamic testIDs: `canCreate-9` (canCreateHabit(9).toString()), `canCreate-10` (canCreateHabit(10).toString()), `canCreate-11` (canCreateHabit(11).toString())
- Feature lock testIDs: `locked-unlimited_habits` (isFeatureLocked('unlimited_habits').toString()), `locked-cloud_sync` (isFeatureLocked('cloud_sync').toString())
- Action buttons: `trigger-paywall` (calls triggerPaywall('test_reason')), `purchase` (calls purchasePackage with mock package)

Use `render()` from `@/lib/test-utils`.

Test cases (~8-10 tests):

1. **Free tier defaults:**
   - isPremium is false by default
   - freeHabitLimit is 10

2. **Habit creation limit (exact limit -- test off-by-one):**
   - canCreateHabit(9) returns true (below limit)
   - canCreateHabit(10) returns false (at limit)
   - canCreateHabit(11) returns false (above limit)
   - canCreateHabit(0) returns true (fresh user)

3. **Feature gating:**
   - isFeatureLocked('unlimited_habits') returns true for free user
   - isFeatureLocked('cloud_sync') returns true for free user
   - After purchasePackage succeeds: isFeatureLocked returns false, canCreateHabit(10) returns true

4. **Paywall triggering:**
   - triggerPaywall sets showPaywall=true and paywallTrigger to reason string
   - setShowPaywall(false) dismisses paywall

5. **Premium state:**
   - purchasePackage resolves to true and sets isPremium=true
   - After premium: canCreateHabit(100) returns true (unlimited)
   - restorePurchases resolves to false (stub implementation)

**Important patterns:**
- PremiumProvider has NO AsyncStorage persistence (pure in-memory) -- no persistence tests needed
- No hydration/restart tests needed
- Focus on behavioral testing of limit logic and feature gating
- Test exact limit value (10) per research recommendation -- catches off-by-one errors
  </action>
  <verify>
Run `npx jest lib/premium-context.test.tsx --verbose` and confirm all tests pass.
Run `npx jest lib/premium-context.test.tsx --coverage` and confirm premium-context.tsx coverage exceeds 80%.
  </verify>
  <done>
PremiumProvider test file verifies: exact 10-habit free tier limit with off-by-one coverage, feature gating for free vs premium users, paywall triggering and dismissal, purchase flow. Coverage of premium-context.tsx exceeds 80%.
  </done>
</task>

</tasks>

<verification>
1. `npx jest lib/theme-context.test.tsx lib/identity-context.test.tsx lib/premium-context.test.tsx --verbose` -- all tests pass
2. Coverage for theme-context.tsx, identity-context.tsx, and premium-context.tsx all exceed 80%
3. ThemeProvider app-restart test passes (mode persists across unmount/remount)
4. PremiumProvider canCreateHabit(9)=true, canCreateHabit(10)=false verified
</verification>

<success_criteria>
- Three test files created: theme-context.test.tsx, identity-context.test.tsx, premium-context.test.tsx
- ThemeProvider dark/light switching persists across simulated app restart
- ThemeProvider weekStartDay persists across restart
- IdentityProvider selected areas and statement persist to AsyncStorage
- PremiumProvider 10-habit free tier limit tested exactly (9=true, 10=false, 11=false)
- All three provider files exceed 80% coverage
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/04-integration-tests-quality-gates/04-02-SUMMARY.md`
</output>
